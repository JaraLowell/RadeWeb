using RadegastWeb.Models;

namespace RadegastWeb.Services
{
    /// <summary>
    /// Unified service for processing all chat messages through a coordinated pipeline
    /// </summary>
    public interface IChatProcessingService
    {
        /// <summary>
        /// Process a chat message through all registered processors (AI, Corrade, logging, etc.)
        /// </summary>
        /// <param name="message">The chat message to process</param>
        /// <param name="accountId">The account ID that received the message</param>
        /// <returns>Task representing the async operation</returns>
        Task ProcessChatMessageAsync(ChatMessageDto message, Guid accountId);

        /// <summary>
        /// Register a chat processor with the pipeline
        /// </summary>
        /// <param name="processor">The processor to register</param>
        /// <param name="priority">Priority order (lower numbers execute first)</param>
        void RegisterProcessor(IChatMessageProcessor processor, int priority = 100);

        /// <summary>
        /// Unregister a chat processor from the pipeline
        /// </summary>
        /// <param name="processor">The processor to unregister</param>
        void UnregisterProcessor(IChatMessageProcessor processor);
    }

    /// <summary>
    /// Interface for chat message processors that can be plugged into the pipeline
    /// </summary>
    public interface IChatMessageProcessor
    {
        /// <summary>
        /// Process a chat message
        /// </summary>
        /// <param name="message">The chat message to process</param>
        /// <param name="context">Processing context</param>
        /// <returns>Processing result indicating if pipeline should continue</returns>
        Task<ChatProcessingResult> ProcessAsync(ChatMessageDto message, ChatProcessingContext context);

        /// <summary>
        /// Priority for ordering processors (lower numbers execute first)
        /// </summary>
        int Priority { get; }

        /// <summary>
        /// Name of this processor for logging
        /// </summary>
        string Name { get; }
    }

    /// <summary>
    /// Result from a chat message processor
    /// </summary>
    public class ChatProcessingResult
    {
        /// <summary>
        /// Whether processing was successful
        /// </summary>
        public bool Success { get; set; } = true;

        /// <summary>
        /// Whether the pipeline should continue processing this message
        /// </summary>
        public bool ContinueProcessing { get; set; } = true;

        /// <summary>
        /// Optional error message if processing failed
        /// </summary>
        public string? ErrorMessage { get; set; }

        /// <summary>
        /// Optional response message generated by this processor
        /// </summary>
        public string? ResponseMessage { get; set; }

        /// <summary>
        /// Optional modified message (for URL processing, etc.)
        /// </summary>
        public ChatMessageDto? ModifiedMessage { get; set; }

        public static ChatProcessingResult CreateSuccess() => new() { Success = true, ContinueProcessing = true };
        public static ChatProcessingResult CreateSuccessWithResponse(string response) => new() { Success = true, ContinueProcessing = true, ResponseMessage = response };
        public static ChatProcessingResult CreateSuccessStop() => new() { Success = true, ContinueProcessing = false };
        public static ChatProcessingResult CreateError(string error) => new() { Success = false, ContinueProcessing = false, ErrorMessage = error };
    }

    /// <summary>
    /// Context passed to chat processors
    /// </summary>
    public class ChatProcessingContext
    {
        /// <summary>
        /// The account ID processing this message
        /// </summary>
        public Guid AccountId { get; set; }

        /// <summary>
        /// WebRadegast instance for this account
        /// </summary>
        public Core.WebRadegastInstance? AccountInstance { get; set; }

        /// <summary>
        /// Recent chat history for context
        /// </summary>
        public IEnumerable<ChatMessageDto> RecentHistory { get; set; } = Enumerable.Empty<ChatMessageDto>();

        /// <summary>
        /// Shared data between processors
        /// </summary>
        public Dictionary<string, object> SharedData { get; set; } = new();

        /// <summary>
        /// Whether this message has already been saved to the database
        /// </summary>
        public bool MessageSaved { get; set; } = false;

        /// <summary>
        /// Whether this message has already been broadcast via SignalR
        /// </summary>
        public bool MessageBroadcast { get; set; } = false;
    }
}